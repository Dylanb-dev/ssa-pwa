/* eslint-disable */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { initializeApp } from "firebase/app"
import { getStorage, ref, uploadBytes } from "firebase/storage"

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate } from "workbox-strategies"
import XML from "xhr-shim"
import { lineAlgorithm } from "./App"

global["XMLHttpRequest"] = XML

const firebaseConfig = {
	apiKey: "AIzaSyBYAQRyqjZ-vjXT1FikWjmVNDpHe4tiyJs",

	authDomain: "space-exposure-d0379.firebaseapp.com",

	projectId: "space-exposure-d0379",

	storageBucket: "space-exposure-d0379.appspot.com",

	messagingSenderId: "963000608298",

	appId: "1:963000608298:web:985c5a76757cdd41f9c553",
}

// Initialize Firebase
initializeApp(firebaseConfig)

const storageRef = getStorage()

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$")
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== "navigate") {
			return false
		} // If this is a URL that starts with /_, skip.

		if (url.pathname.startsWith("/_")) {
			return false
		} // If this looks like a URL for a resource, because it contains // a file extension, skip.

		if (url.pathname.match(fileExtensionRegexp)) {
			return false
		} // Return true to signal that we want to use the handler.

		return true
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) =>
		url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: "images",
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting()
	}
})

// Any other custom service worker logic can go here.
let canvasA = null
let canvasB = null

let count = 0

self.addEventListener("message", async (event) => {
	canvasA = new OffscreenCanvas(100, 1)
	canvasB = new OffscreenCanvas(100, 1)

	if (event.data.bitmap && !event.data.msg) {
		console.log("processing bitmap")
		console.log(event.data.bitmap)
		console.log("PROCESSING EVENT")

		const date = new Date().toString()
		const { bitmap, group } = event.data
		const ctx = canvasA.getContext("2d", { willReadFrequently: true })
		ctx.globalCompositeOperation = "difference"
		let width = bitmap.width / 3
		let height = bitmap.height / 3
		canvasA.width = width
		canvasA.height = height
		ctx.drawImage(bitmap, 0, 0, width, height)
		console.log("draw image")
		count++

		if (count > 1) {
			const imageData = ctx.getImageData(0, 0, width, height)
			const { longestObject } = lineAlgorithm(imageData)
			if (longestObject.size > 7) {
				console.log("detected a positive diff, uploading image")
				canvasB.width = bitmap.width
				canvasB.height = bitmap.height
				const ctxB = canvasB.getContext("bitmaprenderer")
				ctxB.transferFromImageBitmap(bitmap)
				canvasB
					.convertToBlob({ type: "image/jpeg", quality: 0.95 })
					.then(async (res) => {
						console.log(res)
						count = count + 1
						var imagesRef = ref(storageRef, `${group}/${date}`)
						await uploadBytes(imagesRef, res)
						console.log(`uploaded to firebase ${group}/${date}`)
					})
				// self.clients.matchAll().then(function (clients) {
				// 	clients.forEach(function (client) {
				// 		client.postMessage({
				// 			date,
				// 			longestObject,
				// 			bitmap,
				// 			msg: "Hey I just got a fetch from you!",
				// 		})
				// 	})
				// })
			}
		}
	}
})
