/* eslint-disable */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { initializeApp } from "firebase/app"
import { getStorage, ref, uploadString } from "firebase/storage"

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate } from "workbox-strategies"
import { format } from "date-fns"

import piexif from "./piexifjs"

// @ts-ignore
import XML from "xhr-shim"
import { lineAlgorithm } from "./App"

// @ts-ignore
global["XMLHttpRequest"] = XML

const firebaseConfig = {
	apiKey: "AIzaSyBYAQRyqjZ-vjXT1FikWjmVNDpHe4tiyJs",

	authDomain: "space-exposure-d0379.firebaseapp.com",

	projectId: "space-exposure-d0379",

	storageBucket: "space-exposure-d0379.appspot.com",

	messagingSenderId: "963000608298",

	appId: "1:963000608298:web:985c5a76757cdd41f9c553",
}

// Initialize Firebase
initializeApp(firebaseConfig)

const storageRef = getStorage()

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
// @ts-ignore
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$")
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== "navigate") {
			return false
		} // If this is a URL that starts with /_, skip.

		if (url.pathname.startsWith("/_")) {
			return false
		} // If this looks like a URL for a resource, because it contains // a file extension, skip.

		if (url.pathname.match(fileExtensionRegexp)) {
			return false
		} // Return true to signal that we want to use the handler.

		return true
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) =>
		url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: "images",
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		// @ts-ignore
		self.skipWaiting()
	}
})

// Any other custom service worker logic can go here.
let canvasA = null
let canvasB = null
let lightenContext
let differenceContext
let imageData = {}

self.addEventListener("message", async (event) => {
	console.log(`service worker recieved ${JSON.stringify(event.data)}`)

	if (event.data.diffWidth) {
		console.log("setting contexts")
		const { diffWidth, diffHeight, width, height } = event.data
		canvasA = new OffscreenCanvas(width, height)
		canvasB = new OffscreenCanvas(Math.floor(diffWidth), Math.floor(diffHeight))

		console.log({ diffWidth, diffHeight, width, height })

		lightenContext = canvasA.getContext("2d", { willReadFrequently: true })
		//@ts-ignore
		lightenContext.globalCompositeOperation = "lighten"

		differenceContext = canvasB.getContext("2d", { willReadFrequently: true })
		//@ts-ignore
		differenceContext.globalCompositeOperation = "difference"
		console.log(lightenContext, differenceContext)
	}

	if (event.data.bitmap && event.data.group && event.data.number) {
		console.log("processing bitmap")
		console.log(event.data.bitmap)
		console.log("PROCESSING EVENT")

		const date = new Date().toString()
		const { bitmap, group, number } = event.data

		const downWidth = Math.floor(bitmap.width / 3)
		const downHeight = Math.floor(bitmap.height / 3)
		const height = bitmap.height
		const width = bitmap.width

		console.log({ differenceContext, lightenContext })
		differenceContext.drawImage(bitmap, 0, 0, downWidth, downHeight)
		lightenContext.drawImage(bitmap, 0, 0, width, height)
		bitmap.close()
		// If frames 0-3, just build up lighten and difference image
		// if (number % 3 !== 0) {
		// 	console.log(`drawing frame ${number}`)
		// 	differenceContext.drawImage(bitmap, 0, 0, downWidth, downHeight)
		// 	lightenContext.drawImage(bitmap, 0, 0, width, height)
		// 	bitmap.close()
		// }
		// Do streak detection, save image if has streak, reset canvases
		if (number !== 0 && number % 3 === 0) {
			console.log(`drawing frame ${number} and checking for streak`)

			console.log({ event })
			imageData = differenceContext.getImageData(0, 0, downWidth, downHeight)
			const { longestObject } = lineAlgorithm(imageData)
			console.log({ longestObject })
			imageData = {}
			// Streak found, create final image
			if (longestObject.size > 10 && longestObject.size < 500) {
				var zeroth = {}
				let exif = {}
				let gps = {}
				exif[piexif.ExifIFD.DateTimeOriginal] = format(
					new Date(date),
					"yyyy:MM:dd HH:mm:SS"
				)
				exif[piexif.ExifIFD.ExposureTime] = "4s"
				exif[36880] = "+08:00"
				var lat = -32.05
				var lng = 115.9
				gps[piexif.GPSIFD.GPSLatitudeRef] = lat < 0 ? "S" : "N"
				gps[piexif.GPSIFD.GPSLatitude] = piexif.GPSHelper.degToDmsRational(lat)
				gps[piexif.GPSIFD.GPSLongitudeRef] = lng < 0 ? "W" : "E"
				gps[piexif.GPSIFD.GPSLongitude] = piexif.GPSHelper.degToDmsRational(lng)
				var exifObj = { "0th": zeroth, Exif: exif, GPS: gps }
				var exifbytes = piexif.dump(exifObj)

				const blob = await canvasA.convertToBlob({
					type: "image/jpeg",
					quality: 0.95,
				})

				var reader = new FileReader()
				reader.onload = function (e) {
					//@ts-ignore
					var jpegData = piexif.insert(exifbytes, e.target.result)
					console.log("pushing jpeg")
					//@ts-ignore
					event.source.postMessage({
						jpeg: jpegData,
						date,
						longestObject,
					})
					var imagesRef = ref(
						storageRef,
						`${group}/${new Date(date).toString()}`
					)
					uploadString(imagesRef, jpegData, "data_url")
					console.log(
						`uploaded to firebase ${group}/${new Date(date).toString()}`
					)
					// reset canvases
					canvasA = new OffscreenCanvas(width, height)
					lightenContext = canvasA.getContext("2d", {
						willReadFrequently: true,
					})
					//@ts-ignore
					lightenContext.globalCompositeOperation = "lighten"

					canvasB = new OffscreenCanvas(downWidth, downHeight)
					differenceContext = canvasB.getContext("2d", {
						willReadFrequently: true,
					})
					//@ts-ignore
					differenceContext.globalCompositeOperation = "difference"
				}
				reader.readAsDataURL(blob)
			} else {
				// reset canvases
				canvasA = new OffscreenCanvas(width, height)
				lightenContext = canvasA.getContext("2d", { willReadFrequently: true })
				//@ts-ignore
				lightenContext.globalCompositeOperation = "lighten"

				canvasB = new OffscreenCanvas(downWidth, downHeight)
				differenceContext = canvasB.getContext("2d", {
					willReadFrequently: true,
				})
				//@ts-ignore
				differenceContext.globalCompositeOperation = "difference"
			}
		}
		// First frame, no streak logic
		// else if (number === 0) {
		// 	differenceContext.drawImage(bitmap, 0, 0, downWidth, downHeight)
		// 	lightenContext.drawImage(bitmap, 0, 0, width, height)
		// 	bitmap.close()
		// }
	}
})
