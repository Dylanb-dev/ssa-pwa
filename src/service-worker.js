/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { initializeApp } from "firebase/app"
import { getStorage, ref, uploadBytes } from "firebase/storage"

import { clientsClaim } from "workbox-core"
import { ExpirationPlugin } from "workbox-expiration"
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching"
import { registerRoute } from "workbox-routing"
import { StaleWhileRevalidate } from "workbox-strategies"
import XML from "xhr-shim"

global["XMLHttpRequest"] = XML

const firebaseConfig = {
	apiKey: "AIzaSyBYAQRyqjZ-vjXT1FikWjmVNDpHe4tiyJs",

	authDomain: "space-exposure-d0379.firebaseapp.com",

	projectId: "space-exposure-d0379",

	storageBucket: "space-exposure-d0379.appspot.com",

	messagingSenderId: "963000608298",

	appId: "1:963000608298:web:985c5a76757cdd41f9c553",
}

// Initialize Firebase
initializeApp(firebaseConfig)

const storageRef = getStorage()

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$")
registerRoute(
	// Return false to exempt requests from being fulfilled by index.html.
	({ request, url }) => {
		// If this isn't a navigation, skip.
		if (request.mode !== "navigate") {
			return false
		} // If this is a URL that starts with /_, skip.

		if (url.pathname.startsWith("/_")) {
			return false
		} // If this looks like a URL for a resource, because it contains // a file extension, skip.

		if (url.pathname.match(fileExtensionRegexp)) {
			return false
		} // Return true to signal that we want to use the handler.

		return true
	},
	createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
)

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
	// Add in any other file extensions or routing criteria as needed.
	({ url }) =>
		url.origin === self.location.origin && url.pathname.endsWith(".png"), // Customize this strategy as needed, e.g., by changing to CacheFirst.
	new StaleWhileRevalidate({
		cacheName: "images",
		plugins: [
			// Ensure that once this runtime cache reaches a maximum size the
			// least-recently used images are removed.
			new ExpirationPlugin({ maxEntries: 50 }),
		],
	})
)

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting()
	}
})

// Any other custom service worker logic can go here.

let canvasB = null
let group = null
let bitmap = null
// Waiting to receive the OffScreenCanvas
self.addEventListener("message", (event) => {
	const datestring = new Date().toString()
	if (event.data.canvas) {
		canvasB = event.data.canvas
	} else {
		bitmap = event.data.bitmap
		group = event.data.group
		let count = 0
		const canvas = canvasB
		canvas.width = bitmap.width
		canvas.height = bitmap.height
		const ctx = canvas.getContext("bitmaprenderer")
		ctx.transferFromImageBitmap(bitmap)
		console.log(canvas)

		canvas
			.convertToBlob({ type: "image/jpeg", quality: 0.99 })
			.then(async (res) => {
				console.log(res)
				count = count + 1
				var imagesRef = ref(storageRef, `${group}/${datestring}`)
				await uploadBytes(imagesRef, res)
				console.log(`uploaded to firebase ${group}/${datestring}`)
			})
	}
})
